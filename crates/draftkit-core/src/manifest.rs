//! Manifest reader with runtime-first, embedded-fallback loading.
//!
//! The manifest.json file is generated by the collector script and contains
//! metadata about when the data was downloaded, who downloaded it, and counts
//! of embedded components/templates.
//!
//! Loading priority:
//! 1. Runtime data directory (`~/.local/share/draftkit/manifest.json`)
//! 2. Embedded data (compile-time via `include_dir!`)

#[cfg(feature = "embedded-data")]
use include_dir::{Dir, include_dir};
use serde::Deserialize;
use std::sync::OnceLock;

use crate::data_dir::{DataSource, runtime_manifest_path};

/// Embedded cache directory containing manifest.json
#[cfg(feature = "embedded-data")]
static CACHE_DIR: Dir<'_> = include_dir!("$CARGO_MANIFEST_DIR/cache");

/// Cached manifest data with source tracking
static MANIFEST: OnceLock<(Option<Manifest>, DataSource)> = OnceLock::new();

/// Version information from manifest
#[derive(Debug, Clone, Deserialize)]
pub struct ManifestVersions {
    /// Tailwind CSS version (e.g., "4.1")
    pub tailwind: String,
    /// Elements package version (e.g., "1.0.22")
    pub elements: String,
    /// Inertia hash/version
    pub inertia: String,
}

/// Count information from manifest
#[derive(Debug, Clone, Deserialize)]
pub struct ManifestCounts {
    /// Total number of UI components
    pub components: u32,
    /// Number of format variations (framework × version × mode)
    pub formats: u32,
    /// Number of template kits
    pub kits: u32,
    /// Number of templates available for download
    pub templates_available: u32,
}

/// Template info from manifest
#[derive(Debug, Clone, Deserialize)]
pub struct TemplateInfo {
    /// Template name (e.g., "Transmit", "Primer")
    pub name: String,
    /// Date of last changelog update
    pub changelog_date: String,
    /// File modification time
    pub file_mtime: String,
}

/// The embedded manifest containing build/download metadata
#[derive(Debug, Clone, Deserialize)]
pub struct Manifest {
    /// ISO 8601 timestamp of when data was downloaded
    pub downloaded_at: String,
    /// Email of the licensed user who downloaded the data
    pub downloaded_by: String,
    /// Optional suffix for the download
    #[serde(default)]
    pub suffix: Option<String>,
    /// Version information for embedded data sources
    pub versions: ManifestVersions,
    /// Counts of embedded data
    pub counts: ManifestCounts,
    /// List of available templates
    pub templates: Vec<TemplateInfo>,
    /// List of data source descriptions
    pub data_sources: Vec<String>,
}

impl Manifest {
    /// Extract just the date portion from downloaded_at (YYYY-MM-DD)
    #[must_use]
    pub fn download_date(&self) -> &str {
        // downloaded_at is like "2026-01-13T00:16:25Z"
        self.downloaded_at
            .split('T')
            .next()
            .unwrap_or(&self.downloaded_at)
    }

    /// Get the licensed user's email
    #[must_use]
    pub fn licensed_to(&self) -> &str {
        &self.downloaded_by
    }
}

/// Try to load manifest from runtime data directory.
fn load_runtime_manifest() -> Option<Manifest> {
    let path = runtime_manifest_path()?;
    let contents = std::fs::read_to_string(path.as_std_path()).ok()?;
    serde_json::from_str(&contents).ok()
}

/// Load manifest from embedded data.
#[cfg(feature = "embedded-data")]
fn load_embedded_manifest() -> Option<Manifest> {
    CACHE_DIR
        .get_file("manifest.json")
        .and_then(|f| f.contents_utf8())
        .and_then(|contents| serde_json::from_str(contents).ok())
}

/// Load manifest from embedded data (stub when no embedded data).
#[cfg(not(feature = "embedded-data"))]
fn load_embedded_manifest() -> Option<Manifest> {
    None
}

/// Initialize manifest with runtime-first, embedded-fallback strategy.
fn init_manifest() -> (Option<Manifest>, DataSource) {
    // Try runtime first
    if let Some(manifest) = load_runtime_manifest() {
        return (Some(manifest), DataSource::Runtime);
    }

    // Fall back to embedded
    if let Some(manifest) = load_embedded_manifest() {
        return (Some(manifest), DataSource::Embedded);
    }

    (None, DataSource::None)
}

/// Get the manifest, trying runtime first then embedded.
#[must_use]
pub fn get_manifest() -> Option<&'static Manifest> {
    MANIFEST.get_or_init(init_manifest).0.as_ref()
}

/// Get the source of the currently loaded manifest.
#[must_use]
pub fn manifest_source() -> DataSource {
    MANIFEST.get_or_init(init_manifest).1
}

/// Build information available at compile time
pub struct BuildInfo {
    /// Package version from Cargo.toml
    pub version: &'static str,
    /// Build timestamp (requires build.rs setup, falls back to empty)
    pub build_date: &'static str,
    /// Git commit hash if available
    pub git_hash: &'static str,
}

impl BuildInfo {
    /// Create build info from compile-time environment
    #[must_use]
    pub const fn new() -> Self {
        Self {
            version: env!("CARGO_PKG_VERSION"),
            // These would require a build.rs to set; use empty for now
            build_date: "",
            git_hash: "",
        }
    }
}

impl Default for BuildInfo {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_info_has_version() {
        let info = BuildInfo::new();
        assert!(!info.version.is_empty());
    }

    #[test]
    fn test_get_manifest_returns_option() {
        // Just verify it doesn't panic
        let _ = get_manifest();
    }

    #[cfg(feature = "embedded-data")]
    #[test]
    fn test_manifest_download_date_extraction() {
        if let Some(manifest) = get_manifest() {
            let date = manifest.download_date();
            // Should be YYYY-MM-DD format
            assert!(date.len() >= 10);
            assert!(date.contains('-'));
        }
    }
}
